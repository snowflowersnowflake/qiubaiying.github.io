---
layout:     post
title:      pandas笔记
subtitle:   #
date:       2019-9-22
author:     y00
header-img: img/ayano.jpg
catalog: true
tags:
    - python
    - pandas
    - 机器学习
---



<iframe
  frameborder="no"
  border="0"
  marginwidth="0"
  marginheight="0"
  width="330"
  height="86"
  src="//music.163.com/outchain/player?type=2&id=35505031&auto=0&height=66"
></iframe>





# 引言
Pandas 是基于 NumPy 的一种数据处理工具，该工具为了解决数据分析任务而创建。
Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的函数和方法。
对于机器学习算法的练习题来说，pandas更是必不可少，往往决定正确率的是特征工程而不是使用的算法模型。
pandas常常和numpy一起使用，进行数据的采样与处理。

# Pandas 的数据结构
Pandas 主要有 Series（一维数组），DataFrame（二维数组），Panel（三维数组），Panel4D（四维数组），PanelND（更多维数组）等数据结构。
其中 Series 和 DataFrame 应用的最为广泛。

* Series 是一维带标签的数组，它可以包含任何数据类型。包括整数，字符串，浮点数，Python 对象等。Series 可以通过标签来定位。
* DataFrame 是二维的带标签的数据结构。我们可以通过标签来定位数据。这是 NumPy 所没有的。

#导入所需要使用到的库

```python
import pandas as pd
import numpy as np
print(pd.__version__)#打印版本
```

# pandas进阶操作
基础的数据操作观看实例比照就能理解，进阶部分笔者会补充部分解释信息

# 时间序列索引

## 建立一个以 2018 年每一天为索引，值为随机数的 Series

```python
dti = pd.date_range(start='2018-01-01', end='2018-12-31', freq='D')
s = pd.Series(np.random.rand(len(dti)), index=dti)
print (s)
```

设置时间的起始和结束freq控制随机数的间隔频率，采用"D"的时候打印每天为单位的信息，然后将此作为index
np.random.rand返回【0,1】范围内的一个随机数
返回随机数的个数是len(dti)，以使每个Series中的索引都能匹配到一个随机数。

```txt
2018-01-01    0.289422
2018-01-02    0.322898
2018-01-03    0.663779
2018-01-04    0.513682
2018-01-05    0.996929
2018-01-06    0.303355
2018-01-07    0.466621
2018-01-08    0.079008
2018-01-09    0.775039
2018-01-10    0.198569
2018-01-11    0.401680
2018-01-12    0.126774
2018-01-13    0.875948
2018-01-14    0.086280
2018-01-15    0.048911
2018-01-16    0.687690
2018-01-17    0.765243
2018-01-18    0.623987
2018-01-19    0.407055
2018-01-20    0.802661
2018-01-21    0.644146
2018-01-22    0.511044
2018-01-23    0.426378
2018-01-24    0.769499
2018-01-25    0.011949
2018-01-26    0.667829
2018-01-27    0.295917
2018-01-28    0.114008
2018-01-29    0.201223
2018-01-30    0.791230
                ...   
2018-12-02    0.981167
2018-12-03    0.418215
2018-12-04    0.553704
2018-12-05    0.503421
2018-12-06    0.038832
2018-12-07    0.837607
2018-12-08    0.250743
2018-12-09    0.011625
2018-12-10    0.107244
2018-12-11    0.689305
2018-12-12    0.956466
2018-12-13    0.185858
2018-12-14    0.482651
2018-12-15    0.913743
2018-12-16    0.517277
2018-12-17    0.851381
2018-12-18    0.756169
2018-12-19    0.605364
2018-12-20    0.652177
2018-12-21    0.877070
2018-12-22    0.077671
2018-12-23    0.117162
2018-12-24    0.186197
2018-12-25    0.019362
2018-12-26    0.700295
2018-12-27    0.552401
2018-12-28    0.322484
2018-12-29    0.799141
2018-12-30    0.028285
2018-12-31    0.153351
Freq: D, Length: 365, dtype: float64
```
返回结果中会省略中间过程，展示头尾，底部length：表明Series中有365行，内容为浮点数

## 统计s中每一个周三对应值的和

```python
# 周一从 0 开始
print(s[s.index.weekday == 2].sum())
print()
```

```txt
27.832158328241547
```
用sum方法对s中索引为周三的内容求和打印即可，需要注意weekday从0计数

## 统计s中每个月值的平均值

```python
print(s.resample('M').mean())
print()
```

resample方法可以进行重采样
‘M’表示按照月份的方式进行时间重采样，那么原Series中的数据只会保留每月一行
mean方法用来求均值

```txt
2018-01-31    0.449804
2018-02-28    0.464638
2018-03-31    0.484023
2018-04-30    0.486435
2018-05-31    0.558915
2018-06-30    0.540861
2018-07-31    0.545044
2018-08-31    0.512989
2018-09-30    0.483962
2018-10-31    0.456614
2018-11-30    0.523259
2018-12-31    0.488175
Freq: M, dtype: float64
```

结果中对月末进行了重采样
也可以在对应的文档中可以找到该方法的说明，按照自定义的方式来重采样

## 时间转换 s->min

```python
s=pd.date_range('today',periods=100,freq='S')
ts=pd.Series(np.random.randint(0,500,len(s)),index=s)
print(ts)
print()
print(ts.resample('Min').sum())
print()
```

today表示从此刻电脑时间开始采样，以秒为单位，产生的序列赋值给s
然后s作为索引，randint生成随机的整数匹配每一个索引，产生Series指派给ts
然后按照Min的频率重采样，求和

```txt
2019-09-22 17:55:33.806691    434
2019-09-22 17:55:34.806691    254
2019-09-22 17:55:35.806691    105
2019-09-22 17:55:36.806691    114
2019-09-22 17:55:37.806691     39
2019-09-22 17:55:38.806691    127
2019-09-22 17:55:39.806691    342
2019-09-22 17:55:40.806691    117
2019-09-22 17:55:41.806691    120
2019-09-22 17:55:42.806691    179
2019-09-22 17:55:43.806691    488
2019-09-22 17:55:44.806691    140
2019-09-22 17:55:45.806691    375
2019-09-22 17:55:46.806691    277
2019-09-22 17:55:47.806691      7
2019-09-22 17:55:48.806691    212
2019-09-22 17:55:49.806691    433
2019-09-22 17:55:50.806691     67
2019-09-22 17:55:51.806691    392
2019-09-22 17:55:52.806691    361
2019-09-22 17:55:53.806691    302
2019-09-22 17:55:54.806691    189
2019-09-22 17:55:55.806691    301
2019-09-22 17:55:56.806691    494
2019-09-22 17:55:57.806691     35
2019-09-22 17:55:58.806691    135
2019-09-22 17:55:59.806691     69
2019-09-22 17:56:00.806691    332
2019-09-22 17:56:01.806691    111
2019-09-22 17:56:02.806691    325
                             ... 
2019-09-22 17:56:43.806691    337
2019-09-22 17:56:44.806691    438
2019-09-22 17:56:45.806691    452
2019-09-22 17:56:46.806691    289
2019-09-22 17:56:47.806691    306
2019-09-22 17:56:48.806691    187
2019-09-22 17:56:49.806691      3
2019-09-22 17:56:50.806691    156
2019-09-22 17:56:51.806691    322
2019-09-22 17:56:52.806691    210
2019-09-22 17:56:53.806691    117
2019-09-22 17:56:54.806691    247
2019-09-22 17:56:55.806691    322
2019-09-22 17:56:56.806691     89
2019-09-22 17:56:57.806691    134
2019-09-22 17:56:58.806691    116
2019-09-22 17:56:59.806691    416
2019-09-22 17:57:00.806691    347
2019-09-22 17:57:01.806691     62
2019-09-22 17:57:02.806691    375
2019-09-22 17:57:03.806691    458
2019-09-22 17:57:04.806691    460
2019-09-22 17:57:05.806691    491
2019-09-22 17:57:06.806691     62
2019-09-22 17:57:07.806691    307
2019-09-22 17:57:08.806691    313
2019-09-22 17:57:09.806691    426
2019-09-22 17:57:10.806691    403
2019-09-22 17:57:11.806691     21
2019-09-22 17:57:12.806691     15
Freq: S, Length: 100, dtype: int32

2019-09-22 17:55:00     6108
2019-09-22 17:56:00    15275
2019-09-22 17:57:00     3740
Freq: T, dtype: int32
```

## UTC 世界时间标准

UTC是协调世界时，具体内涵可以搜索了解。
这里仅仅作为一个时区示例，也可以用于本地化GET,CET等等时区


```python
s = pd.date_range('today', periods=1, freq='D')  # 获取当前时间
ts = pd.Series(np.random.randn(len(s)), s)  # 随机数值
print(ts)
ts_utc = ts.tz_localize('UTC')  # 转换为 UTC 时间
print(ts_utc)
```

获取当前的一个时间，匹配一个随机数
只需要用到ts.tz_localize时间本地化方法，可以按照指定时区转换

```txt
2019-09-22 18:14:08.942023    1.136068
Freq: D, dtype: float64
2019-09-22 18:14:08.942023+00:00    1.136068
Freq: D, dtype: float64
```

打印结果中包含了转换前后，可以见到时区的改变
[这个文档](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.tz_localize.html)

##  转换为上海所在时区

```python
ts_utc.tz_convert('Asia/Shanghai')
```

```txt
```
